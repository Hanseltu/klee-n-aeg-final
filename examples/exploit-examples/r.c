#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include "klee/klee.h"
struct Type1 {char data [8];};
struct Type2 {
    int status;
    int* ptr;
};
int (*handler)(const int*);
int goodFunc(const int* var){printf("/////This is a Good function\n");return 0;}
int badFunc(const int* var){printf("/////This is a Evil function\n");return 0;}

int global_a;
int (*global_p)(const int*);

struct {struct Type1* obj1; struct Type2* obj2;} gvar = {};
int main(int argc, char* argv[]){
    gvar.obj1 = (struct Type1*)malloc(sizeof(struct Type1));
    gvar.obj2 = (struct Type2*)malloc(sizeof(struct Type2));
    int res;
    char input[0x30];
    klee_make_symbolic(input, 0x30, "input");
    memcpy (&gvar.obj1->data, input, 0x30);

    printf ("addr of handler: %p. \n", &handler);

    handler = goodFunc; //Here we should call a Good function
    global_p = badFunc;
    if(gvar.obj2->status)
    {
        printf ("crashing path is taken. \n");
        res = *gvar.obj2->ptr;
    }
    else
    {
        // May not be easy to find the native address of local_a and local_p
        int local_a = 100;

        int (*local_p)(const int*);
        global_p = handler + 100;
        global_p = &badFunc;
        //local_p = handler;

        printf ("..........exploiting path is taken. \n");

        *gvar.obj2->ptr = &badFunc; // But we modify it (e.g., to badFunc)

        handler = global_a  + 100;
        //handler = local_a  + 100;
        handler = handler + 100;


        global_p(gvar.obj2->ptr);
        //local_p(gvar.obj2->ptr);

    }
    handler(gvar.obj2->ptr);
    return res;
}

